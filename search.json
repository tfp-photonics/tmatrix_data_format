[
  {
    "objectID": "website/indexing.html",
    "href": "website/indexing.html",
    "title": "Indexing conventions",
    "section": "",
    "text": "We describe in this document two indexing conventions for ordering T-matrix elements."
  },
  {
    "objectID": "website/indexing.html#magnetic-electric-2x2-block-matrix-layout",
    "href": "website/indexing.html#magnetic-electric-2x2-block-matrix-layout",
    "title": "Indexing conventions",
    "section": "Magnetic-electric 2x2 block matrix layout",
    "text": "Magnetic-electric 2x2 block matrix layout\nA common notation in the T-matrix literature is to expand fields in vector spherical waves as,\n\\[\n\\begin{aligned}\n\\mathbf{E}(\\mathbf{r}) = &\\sum_{l=1}^{\\infty} \\sum_{m=-l}^l\\left[a_{m l} \\mathbf{M}_{m l}\\left(k \\mathbf{r}\\right)+b_{m l} \\mathbf{N}_{m l}\\left(k\\mathbf{r}\\right)\\right]  \\\\ {} = & \\sum_{s=1}^2\\sum_{l=1}^{\\infty} \\sum_{m=-l}^l a^{(s)}_{ m l} \\mathbf{\\Psi}^{(s)}_{m l}\\left(k \\mathbf{r}\\right) \\quad \\text{(compact notation)}\n\\end{aligned}\n\\]\n\nl: multipole degree 1:lmax\nm: multipole order, -l:l\ns: multipole polarisation type, 1 (magnetic) or 2 (electric)\n\nand \\(\\mathbf{M}\\equiv \\mathbf{\\Psi}^{(1)}, \\mathbf{N}\\equiv \\mathbf{\\Psi}^{(2)}\\) stand for the “magnetic” and “electric” types, respectively.\nArranging the expansion coefficients in this order naturally leads to the common 2x2 block-matrix displayed below. Explicitly, for a T-matrix with \\(l_\\text{max}=3\\), we can visualise the 900 elements organised as follows:\n\n\n\n\n\n\n\n\n\nTo keep track of the multiple indices, for each block we can introduce a combined p-index such that,\n\\[\np(l,m) = l(l+1)+m\n\\] which here varies as p: 1..15, as each block is of dimension pmax = lmax(lmax+1)+lmax = 3(3+1)+3 = 15.\nThe whole T-matrix is indexed with a combined q-index such that,\n\\[\nq(s,p) = (s-1)p_{max} + p\n\\] which here gives us, q: 1…30. The total T-matrix dimension (along rows/columns) is thus \\(q_{max}=2\\times(l_\\text{max}(l_\\text{max}+1)+l_\\text{max})=30\\).\nIn summary, for a given \\(l_\\text{max}\\) the indices are given by:\n\n\\(l=1:l_\\text{max}\\)\n\\(m=-l:l\\) for each l\n\\(s=1:2\\) for each pair of (l,m)\n\\(p(l,m) = l(l+1)+m\\)\n\\(q(s,p) = (s-1)p_{max} + p\\)\n\nGiven \\(q\\) and \\(l_\\text{max}\\) we can invert these indices as follows,\n\n\\(p = q - (s-1)q_\\text{max}/2\\),\ngiving here, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\n\\(l = \\lfloor\\sqrt{p}\\rfloor\\),\ngiving here 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3\n\\(m = p - l(l+1)\\),\ngiving here -1, 0, 1, -2, -1, 0, 1, 2, -3, -2, -1, 0, 1, 2, 3, -1, 0, 1, -2, -1, 0, 1, 2, -3, -2, -1, 0, 1, 2, 3"
  },
  {
    "objectID": "website/indexing.html#tmat.h5-indexing-convention",
    "href": "website/indexing.html#tmat.h5-indexing-convention",
    "title": "Indexing conventions",
    "section": "tmat.h5 indexing convention",
    "text": "tmat.h5 indexing convention\nIn the tmat.h5 format inherited from Treams, indices are ordered by polarization, m, l (fastest to slowest). We can convert to this indexing by calculating new indices u, u' such that:\n\\[u = 2(p-1) + (3-s)\\] where \\((3-s)\\) swaps electric and magnetic ordering (1 is electric in tmat.h5, 2 magnetic, but in the original block-matrix layout the first index is magnetic). Noting this little change, the index \\(u\\) simply alternates terms from the electric/magnetic blocks. Below is a reference table for the conversions taking place for the example of \\(l_\\text{max}=3\\). The index \\(q\\) runs from 1 to 30, and the corresponding index \\(u\\) in tmat.h5 convention has the elements reordered.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n\nu\n2\n4\n6\n8\n10\n12\n14\n16\n18\n20\n22\n24\n26\n28\n30\n1\n3\n5\n7\n9\n11\n13\n15\n17\n19\n21\n23\n25\n27\n29\n\n\npolar\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\nm\ne\ne\ne\ne\ne\ne\ne\ne\ne\ne\ne\ne\ne\ne\ne\n\n\np\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nl\n1\n1\n1\n2\n2\n2\n2\n2\n3\n3\n3\n3\n3\n3\n3\n1\n1\n1\n2\n2\n2\n2\n2\n3\n3\n3\n3\n3\n3\n3\n\n\nm\n-1\n0\n1\n-2\n-1\n0\n1\n2\n-3\n-2\n-1\n0\n1\n2\n3\n-1\n0\n1\n-2\n-1\n0\n1\n2\n-3\n-2\n-1\n0\n1\n2\n3\n\n\ns\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n\n\n\n\n\nA visual representation of \\((u,u')\\) indices for the original T-matrix entries is shown below:"
  },
  {
    "objectID": "website/smarties_advanced.html",
    "href": "website/smarties_advanced.html",
    "title": "SMARTIES T-matrix with defined accuracy",
    "section": "",
    "text": "This example script for SMARTIES calculates T-matrices with a predefined accuracy, and exports them in .tmat.h5 format. The script is available as standalone script smarties_advanced.m.\nSMARTIES provides some functions to estimate the maximum multipolar order and number of quadrature points required to reach a desired accuracy. We choose here to fix the relative accuracy to \\(10^{-8}\\) for the orientation-averaged extinction cross-section, which results in higher \\(l_\\text{max}\\) values for larger and/or more elongated spheroids. Note that in some cases SMARTIES may fail to achieve the requested accuracy, in which case a manual adjustment of the convergence parameters may help.\n\npath(pathdef); % clear previous path changes\naddpath(genpath('~/Documents/nano-optics/smarties/'));\naddpath(genpath('~/Documents/nano-optics/easyh5/'));\nclearvars;\n\n%% example\n\n% requested precision (OA Cext)\naccuracy = 1e-8;\n\n% prolate Au spheroid in water\n% semi-axes a=b=20nm, c=40nm\nwavelength = 400:50:800; wavelength = wavelength(:); \nNl = length(wavelength);\nepsilon=epsAu(wavelength);\nmedium=1.33;\n\n% constant simulation parameters\nstParams.a=20;\nstParams.c=40;\n\n% internal options\nstOptions.bGetR = false;\nstOptions.Delta = 0;\nstOptions.NB = 0; % NB will be estimated automatically\nstOptions.bGetSymmetricT = false;\nstOptions.bOutput = false; % verbosity\n\nWe first estimate the maximum convergence parameters required\n\n\nglobalN = 1;\nglobalnNbTheta = 1;\n\n% loop over wavelengths\nfor i=1:Nl\n    stParams.k1=medium*2*pi/wavelength(i);\n    stParams.s=sqrt(epsilon(i)) / medium;\n    % Estimated convergence params\n    [N, nNbTheta] = sphEstimateNandNT(stParams, stOptions, accuracy);\n    stParams.N=N; stParams.nNbTheta=nNbTheta;\n    % Increase params to test accuracy\n    stParams2=stParams;\n    stParams2.N=stParams2.N+5;\n    stParams2.nNbTheta=stParams2.nNbTheta+5;\n\n    [stCoa, stT] = slvForT(stParams,stOptions);\n    [stCoa2, stT2] = slvForT(stParams2,stOptions);\n\n    if(stOptions.bOutput)\n        fprintf('Convergence testing... lambda = %.5g\\n', wavelength(i));\n        fprintf('&lt;Cext&gt; = %.10g,   relative error: %.2g\\n', stCoa.Cext, abs(stCoa.Cext./stCoa2.Cext-1));\n        fprintf('&lt;Csca&gt; = %.10g,   relative error: %.2g\\n', stCoa.Csca, abs(stCoa.Csca./stCoa2.Csca-1));\n        fprintf('&lt;Cabs&gt; = %.10g,   relative error: %.2g\\n', stCoa.Cabs, abs(stCoa.Cabs./stCoa2.Cabs-1));\n    end\n\n    if(abs(stCoa.Cext./stCoa2.Cext-1) &gt; 1.1*accuracy)\n        % try once more\n\n        stParams=stParams2;\n        stParams.N=stParams2.N+5;\n        stParams.nNbTheta=stParams2.nNbTheta+5;\n        [stCoa, stT] = slvForT(stParams,stOptions);\n        [stCoa2, stT2] = slvForT(stParams2,stOptions);\n\n        if(abs(stCoa.Cext./stCoa2.Cext-1) &gt; 1.1*accuracy)\n\n            warning(fprintf('requested precision was not achieved for  = %.5g\\n', wavelength(i)))\n        end\n\n    end\n\n    globalN = max(globalN, stParams.N);\n    globalnNbTheta = max(globalnNbTheta, stParams.nNbTheta);\nend\n\nNext, we redo the calculations for all wavelengths with these fixed parameters, and collect the results in an array suitable for export to .tmat.h5 format.\n\n\nstParams.N=globalN; stParams.nNbTheta=globalnNbTheta;\n    \n% allocate 3D array for all results\nqmax = 2*(globalN*(globalN + 1) + globalN );\ntmatrix = zeros(length(wavelength), qmax, qmax);\n\nfor i=1:Nl\n    stParams.k1=medium*2*pi/wavelength(i);\n    stParams.s=sqrt(epsilon(i)) / medium;\n\n    [stCoa, stT] = slvForT(stParams,stOptions);\n\n    [T, u, up] = expand_tmat(stT, qmax); % tmatrix elements and indices\n    ind = sub2ind(size(tmatrix),u*0+i, u, up); % linear index in 3D array\n    tmatrix(ind) =  T(:,7) + 1i*T(:,8);\n\nend\n% keep note of which elements are known to be exact zeros\nanalytical_zeros = true(qmax,qmax);\nanalytical_zeros(sub2ind(size(analytical_zeros), u, up)) = false;\n\nFinally, we export the data into HDF5.\n\nepsilon = struct(...\n    'embedding', medium^2, 'particle', epsilon, 'embedding_name', 'H2O, Water', ...\n    'embedding_keywords', 'non-dispersive', 'embedding_reference', 'constant', ...\n    'material_name', 'Au, Gold', 'material_reference', 'Au from Johnson and Christy 1972',...\n    'material_keywords', 'dispersive, plasmonic');\n\ngeometry = struct('radiusxy', stParams.a, 'radiusz', stParams.c);\n\ncomputation = struct('description', 'Computation using SMARTIES, a numerically robust EBCM implementation for spheroids', ...\n    'accuracy', 1e-10, 'Lmax', stParams.N, 'Ntheta', stParams.nNbTheta, ...\n    'analytical_zeros', analytical_zeros);\n\ncomments = struct('name', 'Au prolate spheroid in water',...\n    'description', 'Computation using SMARTIES, a numerically robust EBCM implementation for spheroids',...\n    'keywords', 'gold, spheroid, ebcm', 'script', [mfilename '.m']);\n\ntmatrix_hdf5('smarties_advanced.tmat.h5', tmatrix, wavelength, epsilon,...\n              geometry, computation, comments)\n\n\nOutput file: smarties_advanced.tmat.h5"
  },
  {
    "objectID": "website/terms_tetrahedron.html",
    "href": "website/terms_tetrahedron.html",
    "title": "Tetrahedron comparison in TERMS",
    "section": "",
    "text": "This example script runs TERMS with an input T-matrix in .tmat.h5 format calculated with a separate program (Treams). The results are compared with the built-in calculation for 4 spheres in the same geometry.\nThe input file for the external T-matrix case is\nModeAndScheme 2 3\nMultipoleCutoff 6 6 -3\nWavelength 300 700 200\nMedium 1\nOutputFormat HDF5 tetrahedron_external\nTmatrixFiles 1\ntetrahedron_nm.tmat.h5\nScatterers 1\nTF1 0 0 0 270 0 0 0 1\n\nNote that only vacuum_wavelength in nanometres is supported, and the wavelengths much match exactly. Since the original file stores the information as frequency, we must convert this field into vacuum_wavelength. The script convert_units.jl provides an example for automating such adjustments.\nThe simulation is run at the command line with:\nterms input_tetrahedron_external &gt; log_1_ext\nand produces an output file tetrahedron_external.h5 storing the simulated results. For comparison, we also run the same simulation with 4 spheres computed internally by TERMS (no external T-matrix input). The simulation file for this second simulation is\nModeAndScheme 2 3\nMultipoleCutoff 6 6 -3\nWavelength 300 700 100\nScattererCentredCrossSections\nMedium 1\nOutputFormat HDF5 tetrahedron_internal\nDielectricFunctions 1\n\"9.0d0 0.0d0\"\nScatterers 4\nDF1 -150 -86.60254 -61.23724 50\nDF1  150 -86.60254 -61.23724 60\nDF1    0 173.20508 -61.23724 70\nDF1    0   0.00000 183.71173 80\nBelow is a plot comparing the results, showing excellent agreement."
  },
  {
    "objectID": "website/export_R.html",
    "href": "website/export_R.html",
    "title": "Export to ‘.tmat.h5’ format with R",
    "section": "",
    "text": "This document showcases a basic R script to export T-matrices in the .tmat.h5 HDF5 format. For illustration, we start by producing a dummy dataset. This minimal reproducible example file is available for download as a standalone script: export_R.R."
  },
  {
    "objectID": "website/export_R.html#mockup-input-data",
    "href": "website/export_R.html#mockup-input-data",
    "title": "Export to ‘.tmat.h5’ format with R",
    "section": "Mockup input data",
    "text": "Mockup input data\nConsistent with the other examples, we generate a 50x30x30 array of dummy data, which repeats 50 times (50 wavelengths) a matrix of 900 entries ranging from \\(1+1i\\) (first element, top left) to \\(900 + 900i\\) (last element, bottom right). Note the expectation of row-major ordering in HDF5. The 3x3 top-left block is\n   1.0000 + 1.0000i   2.0000 + 2.0000i   3.0000 + 3.0000i ...\n  31.0000 +31.0000i  32.0000 +32.0000i  33.0000 +33.0000i ...\n  61.0000 +61.0000i  62.0000 +62.0000i  63.0000 +63.0000i ...\n   ...               ...                ...               ...\nThe rhdf5 package has support for a variety of R objects, including lists which are automatically written as grouped objects in HDF5.\n\nlibrary(rhdf5) # note: dev version to support complex\nlibrary(uuid) # uuid\nlibrary(glue) # string interpolation\nlibrary(purrr) # mapping functions\n\n## dummy data\n\n# possibly multiple wavelengths\nwavelength &lt;- seq(400, 800, by=50)\nNl &lt;- length(wavelength)\n\nLmax &lt;- 3\nqmax &lt;- 2*(Lmax*(Lmax+1)+Lmax) # T-matrix size\n\n# dummy 30x30 matrix values for each wavelength\n# note the byrow due to HDF5 expecting\n# row-major ordering vs R's default column-major\ntdata &lt;- matrix(1:qmax^2 + 1i*(1:qmax^2), qmax, qmax, byrow=TRUE)\n\ntmatrix &lt;- array(NA_complex_, c(Nl,qmax,qmax))\nfor(i in seq_len(Nl))\n  tmatrix[i,,] &lt;- tdata\n\ntmatrix[1,1:3,1:3]\n\nmodes &lt;- list(l = rep(NA_integer_, qmax),\n              m = rep(NA_integer_, qmax),\n              polarization = rep(NA_character_, qmax))\n\ni &lt;- 1\nfor (li in 1:Lmax){\n  for (mi in -li:li){\n    for (si in c(\"electric\", \"magnetic\")){\n      modes$l[i] &lt;- li\n      modes$m[i] &lt;- mi\n      modes$polarization[i] &lt;- si\n      i &lt;-  i+1\n    }\n  }\n}\n\nembedding &lt;- list('relative_permeability' = 1.0, \n                  'relative_permittivity' = 1.33^2)\nscatterer &lt;- list(material = list('relative_permeability' = 1.0, \n                                  'relative_permittivity' =\n                                    rep(-11.4+1.181i,Nl)),\n                  geometry = list('radiusxy' = 20.0, \n                                  'radiusz' = 40.0))\n\ncomputation &lt;- list(method_parameters = list('Lmax' = Lmax, \n                                             'Ntheta' = 100),\n                    files = list(script = paste(readLines('export_R.R'), collapse = \"\\n\")))"
  },
  {
    "objectID": "website/export_R.html#saving-to-hdf5",
    "href": "website/export_R.html#saving-to-hdf5",
    "title": "Export to ‘.tmat.h5’ format with R",
    "section": "Saving to HDF5",
    "text": "Saving to HDF5\nThe rhdf5 package provides support for reading/writing HDF5 files into/from R objects. Until my recent request, complex arrays were not supported, but this is now implemented in the dev version of the package.\n\nlibrary(rhdf5) # note: requires dev version to support complex arrays\n# cf https://support.bioconductor.org/p/9156305/#9156408\n# install.packages(\"remotes\")\n# remotes::install_github(\"grimbough/rhdf5@devel\")\n# may need 'crypto' library from openSSL to compile\n# e.g. via brew install openssl on macos\n\nWe can then write the different objects defined above using hwrite. Note the important native = TRUE parameter for the T-matrix data: R stores arrays column-wise, while HDF5 uses row-major ordering. To avoid confusion between different programming languages, we suggest sticking with the native HDF5 convention (native = TRUE ensures that the array is written transposed).\nAttributes don’t seem to have a convenient high-level interface, and unfortunately they need to be written slightly differently for the root level, datasets, and groups.\n\nf &lt;- 'ar.tmat.h5'\nsoftware = sprintf(\"SMARTIES=1.1, R=%s, rhdf5=%s\", paste0(R.version$major, R.version$minor), packageVersion(\"rhdf5\"))\n\nunlink(f) # delete previous file if it exists\nh5createFile(f)\nh5closeAll() # in case connections open\n\nh5write(wavelength, file=f, name=\"/vacuum_wavelength\")\n\nh5write(tmatrix, file=f, name=\"/tmatrix\", native=TRUE) # store rowwise\n\nh5write(modes, file=f, name='/modes')\nh5write(embedding, file=f, name=\"/embedding\")\nh5write(scatterer, file=f, name=\"/scatterer\")\nh5write(computation, file=f, name='/computation')\n\n## write attributes\nfid &lt;- H5Fopen(f)\n# root level\nh5writeAttribute(\"Au prolate spheroid in water\", fid, \"name\")\nh5writeAttribute(\"Computation using SMARTIES, a numerically robust EBCM implementation for spheroids\", fid, \"description\")\nh5writeAttribute(\"gold, spheroid, ebcm, passive, reciprocal, czinfinity, mirrorxyz\", fid, \"keywords\")\nh5writeAttribute(\"v1\", fid, \"storage_format_version\")\n\n# wavelength\ndid &lt;- H5Dopen(fid, \"vacuum_wavelength\")\nh5writeAttribute(\"nm\", did, \"unit\")\nH5Dclose(did)\n\n# embedding\ngid &lt;- H5Gopen(fid, \"embedding\")\nh5writeAttribute(\"H2O, Water\", gid, \"name\")\nh5writeAttribute(\"non-dispersive\", gid, \"keywords\")\nH5Gclose(gid)\n\n# material\ngid &lt;- H5Gopen(fid, \"scatterer/material\")\nh5writeAttribute(\"Au, Gold\", gid, \"name\")\nh5writeAttribute(\"dispersive, plasmonic\", gid, \"keywords\")\nh5writeAttribute(\"Au from Raschke et al 10.1103/PhysRevB.86.235147\", gid, \"reference\")\nH5Gclose(gid)\n\n# geometry\ngid &lt;- H5Gopen(fid, \"scatterer/geometry\")\nh5writeAttribute(\"nm\", gid, \"unit\")\nh5writeAttribute(\"spheroid\", gid, \"shape\")\nh5writeAttribute(\"homogeneous spheroid with symmetry axis z\", gid, \"name\")\nH5Gclose(gid)\n\n# computation\ngid &lt;- H5Gopen(fid, \"computation\")\nh5writeAttribute(\"EBCM, Extended Boundary Condition Method\", gid, \"method\")\nh5writeAttribute(\"Computation using SMARTIES, a numerically robust EBCM implementation for spheroids\", gid, \"description\")\nh5writeAttribute(software, gid, \"software\")\nh5writeAttribute(\"SMARTIES\", gid, \"name\")\nH5Gclose(gid)\n\nH5Fclose(fid)"
  },
  {
    "objectID": "website/terms_comparison.html",
    "href": "website/terms_comparison.html",
    "title": "Importing T-matrices in TERMS",
    "section": "",
    "text": "Below is an example script to run TERMS with input T-matrices in .tmat.h5 format. The input file for this example is available as standalone script terms/input_spheroid1_dimer.\nThe input file for TERMS is\nModeAndScheme 2 3\nMultipoleCutoff 3 3 -3\nWavelength 400 800 200\nMedium 1.7689\nOutputFormat HDF5 smarties_dimer\nTmatrixFiles 1 \nsmarties.tmat.h5\nScatterers 2\nTF1 0 -50 0 40 0 0 0 2\nTF1 0  50 0 40 0 0.7853982 0 2\nNote that only vacuum_wavelength in nanometres is supported, and the wavelengths much match exactly. TERMS does not check the embedding medium, so it also the user’s responsibility to ensure they are identical.\nThe simulation is run at the command line with:\nterms input_spheroid1_dimer &gt; log1\nand produces an output file smarties_dimer.h5 storing the simulated results. For comparison, we also run the same simulation with a T-matrix obtained via Finite-element simulations using JCMsuite. Below is a plot comparing the results."
  },
  {
    "objectID": "website/export_python.html",
    "href": "website/export_python.html",
    "title": "Export to ‘.tmat.h5’ format with Python",
    "section": "",
    "text": "This document showcases a basic Matlab script to export T-matrices in the .tmat.h5 HDF5 format. For illustration, we start by producing a dummy dataset. This minimal reproducible example file is available for download as a standalone script: export_python.py."
  },
  {
    "objectID": "website/export_python.html#mockup-input-data",
    "href": "website/export_python.html#mockup-input-data",
    "title": "Export to ‘.tmat.h5’ format with Python",
    "section": "Mockup input data",
    "text": "Mockup input data\nConsistent with the other examples, we generate a 50x30x30 array of dummy data, which repeats 50 times (50 wavelengths) a matrix of 900 entries ranging from \\(1+1i\\) (first element, top left) to \\(900 + 900i\\) (last element, bottom right). Note the expectation of row-major ordering in HDF5. The 3x3 top-left block is\n   1.0000 + 1.0000i   2.0000 + 2.0000i   3.0000 + 3.0000i ...\n  31.0000 +31.0000i  32.0000 +32.0000i  33.0000 +33.0000i ...\n  61.0000 +61.0000i  62.0000 +62.0000i  63.0000 +63.0000i ...\n   ...               ...                ...               ...\nThe Python library h5py provides a convenient object-oriented interface to save python objects in the required HDF5 structure, so we don’t need particular care to organise them on the Python side.\n\nimport numpy as np\nimport os, sys\nimport h5py\n#possibly multiple wavelengths\nwavelength  = np.arange(400,850, 50)\nNl = len(wavelength)\nlmax = 3\nqmax = 2*(lmax*(lmax+1)+lmax)\n# dummy 30x30 matrix values repeated for each wavelength\ntdata = np.reshape(np.arange(1,901,1) + 1j*np.arange(1,901,1), (qmax,qmax))\ntmatrix = np.zeros((Nl,qmax,qmax), dtype=\"complex\")\nfor i in range(Nl):\n  tmatrix[i,:,:] = tdata\n\nprint(tmatrix[0,0:3,0:3])\n\nl = np.zeros(qmax)\nm = np.zeros(qmax)\ns = np.array([b'xxxxxxic']*len(l))\ni=0\nfor li in range(1,lmax+1):\n    for mi in range(-li, li+1):\n        for si in [b'electric', b'magnetic']:\n            l[i] = li\n            m[i] = mi\n            s[i] = si\n            i = i+1"
  },
  {
    "objectID": "website/export_python.html#saving-to-hdf5",
    "href": "website/export_python.html#saving-to-hdf5",
    "title": "Export to ‘.tmat.h5’ format with Python",
    "section": "Saving to HDF5",
    "text": "Saving to HDF5\nThe Python library h5py provides a convenient interface to generate groups, datasets, and attributes with simple assigments:\n\n# Saving to HDF5\nf = 'ap.tmat.h5';\nwith h5py.File(f, \"w\") as f:\n    f[\"vacuum_wavelength\"] = np.asarray(wavelength)\n    f[\"vacuum_wavelength\"].attrs[\"unit\"] = \"nm\"\n    f[\"tmatrix\"] = tmatrix\n    f['modes/l'] = l\n    f['modes/m'] = m\n    f['modes/polarization'] = s\n    emb = f.create_group(f\"embedding\")\n    emb[\"relative_permittivity\"] = 1.33**2\n    emb[\"relative_permeability\"] = 1.0\n    emb.attrs[\"name\"] = \"H2O, Water\"\n    emb.attrs[\"keywords\"] = \"non-dispersive\"\n    sca_mat = f.create_group(\"scatterer/material\")\n    sca_mat.attrs[\"name\"] = 'Au, Gold'\n    sca_mat.attrs[\"keywords\"] = \"dispersive, plasmonic\"\n    sca_mat.attrs[\"reference\"] = \"Au from Raschke et al 10.1103/PhysRevB.86.235147\"\n    sca_mat[\"relative_permittivity\"] = np.ones(len(wavelength), dtype = complex)*(-11.4+1.181j)\n    sca_mat[\"relative_permeability\"] = 1.0\n    sca_gr = f.create_group(\"scatterer/geometry\")\n    sca_gr[\"radiusxy\"] = 20.0\n    sca_gr[\"radiusz\"] = 40.0\n    sca_gr.attrs['unit'] = 'nm'\n    sca_gr.attrs['shape'] = 'spheroid'\n    sca_gr.attrs['name'] = 'homogeneous spheroid with symmetry axis z'\n    mpar = f.create_group(\"computation/method_parameters\")\n    #f[\"computation/analytical_zeros\"] = analytical_zeros # not needed in this example\n    mpar[\"Lmax\"] = lmax\n    mpar[\"Ntheta\"] = 100\n    f.create_group(\"computation/files\")\n    with open(__file__, \"r\") as scriptfile:\n        f[f\"computation/files/{os.path.basename(__file__)}\"] = scriptfile.read()\n    f[\"computation\"].attrs[\"method\"] = \"EBCM, Extended Boundary Condition Method\" \n    f[\"computation\"].attrs[\"description\"] = \"Computation using SMARTIES, a numerically robust EBCM implementation for spheroids\" \n    f[\"computation\"].attrs[\"software\"] = f\"SMARTIES=1.1, python={sys.version.split()[0]}, h5py={h5py.__version__}\"\n    f[\"computation\"].attrs[\"name\"] = \"SMARTIES\"\n    f.attrs['name'] = 'Au prolate spheroid in water'\n    f.attrs['keywords'] = 'gold, spheroid, ebcm, passive, reciprocal, czinfinity, mirrorxyz'\n    f.attrs['description'] = 'Computation using SMARTIES, a numerically robust EBCM implementation for spheroids'\n    f.attrs['storage_format_version'] = 'v1'"
  },
  {
    "objectID": "website/index.html",
    "href": "website/index.html",
    "title": "T-matrix",
    "section": "",
    "text": "Collection of scripts and self-contained examples to export/import T-matrices."
  },
  {
    "objectID": "website/index.html#examples-of-export-with-dummy-data",
    "href": "website/index.html#examples-of-export-with-dummy-data",
    "title": "T-matrix",
    "section": "Examples of export with dummy data",
    "text": "Examples of export with dummy data\n\nDoc: Julia • Script: export_julia.jl • Output: aj.tmat.h5\nDoc: Matlab • Script: export_matlab.m • Output: am.tmat.h5\nDoc: Python • Script: export_python.py • Output: ap.tmat.h5\nDoc: R • Script: export_R.R • Output: ar.tmat.h5"
  },
  {
    "objectID": "website/index.html#misc.-utilities",
    "href": "website/index.html#misc.-utilities",
    "title": "T-matrix",
    "section": "Misc. utilities",
    "text": "Misc. utilities\n\nConversion\nDisplay\nIndexing"
  },
  {
    "objectID": "website/index.html#smarties-examples",
    "href": "website/index.html#smarties-examples",
    "title": "T-matrix",
    "section": "SMARTIES examples",
    "text": "SMARTIES examples\n\nDoc: Smarties • Script: smarties_simple.m • Output: smarties/smarties_simple.tmat.h5\nDoc: Smarties • Script: smarties_advanced.m • Output: smarties/smarties_advanced.tmat.h5\nBatch example, to run many simulations: smarties_batch"
  },
  {
    "objectID": "website/index.html#terms-examples",
    "href": "website/index.html#terms-examples",
    "title": "T-matrix",
    "section": "TERMS examples",
    "text": "TERMS examples\n\nDimer of spheroids: comparison\nTetrahedron: example"
  },
  {
    "objectID": "website/export_julia.html",
    "href": "website/export_julia.html",
    "title": "Export to ‘.tmat.h5’ format with Julia",
    "section": "",
    "text": "This document showcases a basic Julia script to export T-matrices in the .tmat.h5 HDF5 format. For illustration, we start by producing a dummy dataset. This minimal reproducible example file is available for download as a standalone script: export_julia.jl."
  },
  {
    "objectID": "website/export_julia.html#mockup-input-data",
    "href": "website/export_julia.html#mockup-input-data",
    "title": "Export to ‘.tmat.h5’ format with Julia",
    "section": "Mockup input data",
    "text": "Mockup input data\nConsistent with the other examples, we generate a 50x30x30 array of dummy data, which repeats 50 times (50 wavelengths) a matrix of 900 entries ranging from \\(1+1i\\) (first element, top left) to \\(900 + 900i\\) (last element, bottom right). Note the expectation of row-major ordering in HDF5. The 3x3 top-left block is\n   1.0000 + 1.0000i   2.0000 + 2.0000i   3.0000 + 3.0000i ...\n  31.0000 +31.0000i  32.0000 +32.0000i  33.0000 +33.0000i ...\n  61.0000 +61.0000i  62.0000 +62.0000i  63.0000 +63.0000i ...\n   ...               ...                ...               ...\nFor convenience, we can store compound objects as named tuples, which will then be mapped into HDF5 groups during export.\n\n## mockup data\nusing Pkg, HDF5\n\n# possibly multiple wavelengths\nwavelength = collect(400:50:800)\nNl = length(wavelength)\nLmax = 3\nqmax = 2*(Lmax*(Lmax+1)+Lmax)\n\n# dummy 30x30 matrix values for each wavelength\n# note the row-major ordering\ntdata = transpose(reshape(collect(1:qmax^2) + collect(1:qmax^2) * 1im, (qmax,qmax)))\ntmatrix = zeros(ComplexF64,(Nl,qmax,qmax))\nfor i=1:Nl\n    tmatrix[i,:,:] = tdata\nend\n\nprint(tmatrix[1,1:3,1:3])\n\nl = zeros(Int64, qmax)\nm = zeros(Int64, qmax)\ns = Vector{String}(undef,qmax)\nlet\ni=1\nfor li = 1:Lmax\n    for mi = -li:li\n        for si = [\"electric\", \"magnetic\"]\n            l[i] = li\n            m[i] = mi\n            s[i] = si\n            i = i+1\n        end\n    end\nend\nend"
  },
  {
    "objectID": "website/export_julia.html#saving-to-hdf5",
    "href": "website/export_julia.html#saving-to-hdf5",
    "title": "Export to ‘.tmat.h5’ format with Julia",
    "section": "Saving to HDF5",
    "text": "Saving to HDF5\nComplex arrays are stored with r and i fields as usual. Note that Julia has column-major ordering, unlike HDF5, and we should therefore explicitly transpose the matrix before saving it, to avoid confusion if the data are to be read in another language. Another potential source of error is that the HDF5.jl library orders the array data differently, compared to h5py.\n\nf = \"aj.tmat.h5\"\nver = Pkg.Operations.Context().env.manifest\nh5ver = string(ver[findfirst(v-&gt;v.name == \"HDF5\", ver)].version)\nsoftware = \"SMARTIES=1.1, julia=$(VERSION), HDF5.jl=$(h5ver)\"\n\nh5open(f, \"w\") do fid\n\n    fid[\"vacuum_wavelength\"] = wavelength\n    attributes(fid[\"vacuum_wavelength\"])[\"unit\"] = \"nm\"\n\n    # set = permutedims(dset, reverse(1:ndims(dset)))\n    # https://juliaio.github.io/HDF5.jl/stable/#Language-interoperability-with-row-and-column-major-order-arrays\n    fid[\"tmatrix\"] = permutedims(tmatrix, reverse(1:ndims(tmatrix)))\n\n    modes = create_group(fid, \"modes\") \n    modes[\"l\"] = l\n    modes[\"m\"] = m\n    modes[\"polarization\"] = s\n\n    embedding = create_group(fid, \"embedding\") \n    embedding[\"relative_permittivity\"] = 1.33^2\n    embedding[\"relative_permeability\"] = 1.0\n    attributes(embedding)[\"name\"] = \"H2O, Water\"\n    attributes(embedding)[\"keywords\"] = \"non-dispersive\"\n\n    sca_mat = create_group(fid, \"scatterer/material\") \n    sca_mat[\"relative_permittivity\"] = repeat([-11.4 + 1.181im], Nl)\n    sca_mat[\"relative_permeability\"] = 1.0\n    attributes(sca_mat)[\"name\"] = \"Au, Gold\"\n    attributes(sca_mat)[\"keywords\"] = \"dispersive, plasmonic\"\n    attributes(sca_mat)[\"reference\"] = \"Au from Raschke et al 10.1103/PhysRevB.86.235147\"\n\n    sca_geo = create_group(fid, \"scatterer/geometry\") \n    sca_geo[\"radiusxy\"] = 20.0\n    sca_geo[\"radiusz\"] = 40.0\n    attributes(sca_geo)[\"unit\"] = \"nm\"\n    attributes(sca_geo)[\"shape\"] = \"spheroid\"\n    attributes(sca_geo)[\"name\"] = \"homogeneous spheroid with symmetry axis z\"\n\n    mpar = create_group(fid, \"computation/method_parameters\") \n    mpar[\"Lmax\"] = Lmax\n    mpar[\"Ntheta\"] = 100\n    script = create_group(fid, \"computation/files\") \n    script[\"script\"] = read(\"export_julia.jl\", String)\n    \n    # write root attributes\n    attributes(fid)[\"name\"] = \"Au prolate spheroid in water\"\n    attributes(fid)[\"description\"] = \"Computation using SMARTIES, a numerically robust EBCM implementation for spheroids\"\n    attributes(fid)[\"keywords\"] = \"gold, spheroid, ebcm, passive, reciprocal, czinfinity, mirrorxyz\"    \n    attributes(fid)[\"storage_format_version\"] = \"v1\"\n    \n    # comp attributes\n    attributes(fid[\"computation\"])[\"method\"] = \"EBCM, Extended Boundary Condition Method\"\n    attributes(fid[\"computation\"])[\"description\"] = \"Computation using SMARTIES, a numerically robust EBCM implementation for spheroids\"\n    attributes(fid[\"computation\"])[\"name\"] = \"SMARTIES\"\n    attributes(fid[\"computation\"])[\"software\"] = software\n\nend"
  },
  {
    "objectID": "website/smarties_simple.html",
    "href": "website/smarties_simple.html",
    "title": "Exporting SMARTIES T-matrices",
    "section": "",
    "text": "Below is an example script to run SMARTIES for multiple wavelengths and export the T-matrices in .tmat.h5 format. The script is available as standalone script smarties_simple.m. A slightly more complex script is also provided which automatically adjusts the parameters to reach a given accuracy (smarties_advanced.m).\n\npath(pathdef); % clear previous path changes\naddpath(genpath('~/Documents/nano-optics/smarties/'));\naddpath(genpath('~/Documents/nano-optics/easyh5/'));\nclearvars;\n\nwavelength = (400:50:800)';\nepsilon = epsAu(wavelength); \nmedium=1.33; % water\n\n% spheroid semi-axes\nstParams.a=20; stParams.c=40;\n\n% simulation parameters\nstParams.N=3; stParams.nNbTheta=120;\n\n% additional options if required\nstOptions = {};\n\n% allocate 3D array for all results\nqmax = 2*(stParams.N*(stParams.N + 1) + stParams.N );\ntmatrix = zeros(length(wavelength), qmax, qmax);\n% loop over wavelengths\nfor i=1:length(wavelength)\n    stParams.k1=medium*2*pi/wavelength(i);\n    stParams.s=sqrt(epsilon(i)) / medium;\n    [stCoa, stT] = slvForT(stParams,stOptions);\n    [T, u, up] = expand_tmat(stT, qmax); % tmatrix elements and indices\n    ind = sub2ind(size(tmatrix),u*0+i, u, up); % linear index in 3D array\n    tmatrix(ind) =  T(:,7) + 1i*T(:,8);\nend\n% keep note of which elements are known to be exact zeros\nanalytical_zeros = true(qmax,qmax);\nanalytical_zeros(sub2ind(size(analytical_zeros), u, up)) = false;\n\nFinally, we export the data into HDF5.\n\nepsilon = struct(...\n    'embedding', medium^2, 'particle', epsilon, 'embedding_name', 'H2O, Water', ...\n    'embedding_keywords', 'non-dispersive', 'embedding_reference', 'constant', ...\n    'material_name', 'Au, Gold', 'material_reference', 'Au from Johnson and Christy 1972',...\n    'material_keywords', 'dispersive, plasmonic');\n\ngeometry = struct('radiusxy', stParams.a, 'radiusz', stParams.c);\n\ncomputation = struct('description', 'Computation using SMARTIES, a numerically robust EBCM implementation for spheroids', ...\n    'accuracy', 1e-10, 'Lmax', stParams.N, 'Ntheta', stParams.nNbTheta, ...\n    'analytical_zeros', analytical_zeros);\n\ncomments = struct('name', 'Au prolate spheroid in water',...\n    'description', 'Computation using SMARTIES, a numerically robust EBCM implementation for spheroids',...\n    'keywords', 'gold, spheroid, ebcm', 'script', [mfilename '.m']);\n\ntmatrix_hdf5('smarties_simple.tmat.h5', tmatrix, wavelength, epsilon,...\n              geometry, computation, comments)\n\n\nOutput file: smarties_simple.tmat.h5"
  },
  {
    "objectID": "website/conversion.html",
    "href": "website/conversion.html",
    "title": "Conversion from long format",
    "section": "",
    "text": "Some programs output T-matrices in long format, similar to the example below:\n\n\n  s sp l lp  m mp            Tr            Ti\n1 1  1 1  1 -1 -1 -3.465566e-03 -8.011735e-04\n2 1  1 1  1  0  0 -1.613740e-03 -1.117950e-03\n3 1  1 1  1  1  1 -3.465566e-03 -8.011735e-04\n4 1  1 1  3 -1 -1 -3.133462e-05 -1.028664e-05\n5 1  1 1  3  0  0 -1.315468e-05 -8.618206e-06\n6 1  1 1  3  1  1 -3.133462e-05 -1.028664e-05\n\n\nNote that one advantage of this format is that only non-zero entries need to be provided, similar to a sparse matrix definition. This is useful for EBCM-like analytical methods where particle symmetries dictate that some T-matrix elements be identically zero (plane of symmetry, axis of symmetry, etc.)."
  },
  {
    "objectID": "website/conversion.html#reading-long-format-t-matrix-files",
    "href": "website/conversion.html#reading-long-format-t-matrix-files",
    "title": "Conversion from long format",
    "section": "",
    "text": "Some programs output T-matrices in long format, similar to the example below:\n\n\n  s sp l lp  m mp            Tr            Ti\n1 1  1 1  1 -1 -1 -3.465566e-03 -8.011735e-04\n2 1  1 1  1  0  0 -1.613740e-03 -1.117950e-03\n3 1  1 1  1  1  1 -3.465566e-03 -8.011735e-04\n4 1  1 1  3 -1 -1 -3.133462e-05 -1.028664e-05\n5 1  1 1  3  0  0 -1.315468e-05 -8.618206e-06\n6 1  1 1  3  1  1 -3.133462e-05 -1.028664e-05\n\n\nNote that one advantage of this format is that only non-zero entries need to be provided, similar to a sparse matrix definition. This is useful for EBCM-like analytical methods where particle symmetries dictate that some T-matrix elements be identically zero (plane of symmetry, axis of symmetry, etc.)."
  },
  {
    "objectID": "website/conversion.html#converting-to-wide-format",
    "href": "website/conversion.html#converting-to-wide-format",
    "title": "Conversion from long format",
    "section": "Converting to wide format",
    "text": "Converting to wide format\nThe example script convert_longformat.jl reads this plain text dataset, converts the indices \\((l,m,s)\\) to combined indices \\((u,u')\\), and exports the data in the standard .tmat.h5 format, adding the required metadata.\n## read long data\n# The example below reads T-matrix data from a plain text file output by either SMARTIES (function \n# `exportTmatrix()`) or TERMS (keyword `DumpCollectiveTmatrix`). \n\n# ```\n#   s sp l lp  m mp            Tr            Ti\n# 1 1  1 1  1 -1 -1 -6.049214e-05 -4.266526e-04\n# 2 1  1 1  1  0  0 -3.331557e-05 -3.932179e-04\n# 3 1  1 1  1  1  1 -6.049214e-05 -4.266526e-04\n# 4 1  1 1  3 -1 -1 -2.374705e-07 -1.995117e-06\n# 5 1  1 1  3  0  0 -1.110299e-07 -1.278537e-06\n# 6 1  1 1  3  1  1 -2.374705e-07 -1.995117e-06\n# ...\n# ```\n\nusing Pkg, HDF5, DelimitedFiles, DataFrames, CSV\npwd()\n\n# read all the comments to extract column names, wavelength and epsilon\nf = readlines(open(\"smarties.txt\"))\nbreaks = findall(occursin.(r\"^#\",f))\nf[breaks]\nreps = diff([breaks[2:end]; length(f)+1])\n# meta = filter(line -&gt; occursin(r\"^#\",line),f)\nmeta = f[breaks]\ncolnames = string.(split(meta[1], ' '))[2:9]\nm1 = match.(r\"lambda= ([0-9]+)\",meta[2:end])\nm2 = match.(r\"(?&lt;=epsIn= ).*$\",meta[2:end])\nwavelength = map(x -&gt; parse(Float64,x.captures[1]), m1)\nepsilon = map(x -&gt; parse(Complex{Float64},x.match), m2)\n\nNl = length(wavelength)\n\n# read the T-matrix data\nd = CSV.read(\"smarties.txt\", DataFrame, delim=' ', ignorerepeated=true, comment=\"#\", header=colnames)\n# split by wavelength\nwv = reduce(vcat, [repeat([wavelength[i]], n-1) for (i,n) in enumerate(reps)])\nd.wavelength = wv\ndg = groupby(d, :wavelength, sort=false)\n\nLmax = maximum(d.n)\nqmax = 2*(Lmax*(Lmax+1)+Lmax)\n\n# indices u, u' to place the T-matrix elements\n# in alternating electric/magnetic order\n\ntmat_indexing = function(l,m,s,lmax)\n    p = l * (l + 1) + m\n    pmax = lmax*(lmax+1)+lmax\n    q = (s-1) * pmax + p\n    return 2*(p-1) + (3 - s) # magnetic/electric -&gt; electric/magnetic\nend\n\ntmatrix = zeros(ComplexF64,(Nl,qmax,qmax))\nfor i in 1:Nl\n\nu = tmat_indexing.(dg[i].n, dg[i].m, dg[i].s,Lmax)\nup = tmat_indexing.(dg[i].np, dg[i].mp, dg[i].sp,Lmax)\n    tmatrix[CartesianIndex.(i, u, up)] .= dg[i].Tr + 1im*dg[i].Ti\nend\n\nl = zeros(Int64, qmax)\nm = zeros(Int64, qmax)\ns = Vector{String}(undef,qmax)\nlet\ni=1\nfor li = 1:Lmax\n    for mi = -li:li\n        for si = [\"electric\",\"magnetic\"]\n            l[i] = li\n            m[i] = mi\n            s[i] = si\n            i = i+1\n        end\n    end\nend\nend\n\n\nf = \"aj.tmat.h5\"\nver = Pkg.Operations.Context().env.manifest\nh5ver = string(ver[findfirst(v-&gt;v.name == \"HDF5\", ver)].version)\nsoftware = \"SMARTIES=1.1, julia=$(VERSION), HDF5.jl=$(h5ver)\"\n\nh5open(f, \"w\") do fid\n\n    fid[\"vacuum_wavelength\"] = wavelength\n    attributes(fid[\"vacuum_wavelength\"])[\"unit\"] = \"nm\"\n\n    # https://juliaio.github.io/HDF5.jl/stable/#Language-interoperability-with-row-and-column-major-order-arrays\n    fid[\"tmatrix\"] = permutedims(tmatrix, reverse(1:ndims(tmatrix)))\n\n    modes = create_group(fid, \"modes\") \n    modes[\"l\"] = l\n    modes[\"m\"] = m\n    modes[\"polarization\"] = s\n\n    embedding = create_group(fid, \"embedding\") \n    embedding[\"relative_permittivity\"] = 1.33^2\n    embedding[\"relative_permeability\"] = 1.0\n    attributes(embedding)[\"name\"] = \"H2O, Water\"\n    attributes(embedding)[\"keywords\"] = \"non-dispersive\"\n\n    sca_mat = create_group(fid, \"scatterer/material\") \n    sca_mat[\"relative_permittivity\"] = epsilon\n    sca_mat[\"relative_permeability\"] = 1.0\n    attributes(sca_mat)[\"name\"] = \"Au, Gold\"\n    attributes(sca_mat)[\"keywords\"] = \"dispersive, plasmonic\"\n    attributes(sca_mat)[\"reference\"] = \"Au from Raschke et al 10.1103/PhysRevB.86.235147\"\n\n    sca_geo = create_group(fid, \"scatterer/geometry\") \n    sca_geo[\"radiusxy\"] = 20.0\n    sca_geo[\"radiusz\"] = 40.0\n    attributes(sca_geo)[\"unit\"] = \"nm\"\n    attributes(sca_geo)[\"shape\"] = \"spheroid\"\n    attributes(sca_geo)[\"name\"] = \"homogeneous spheroid with symmetry axis z\"\n\n    mpar = create_group(fid, \"computation/method_parameters\") \n    mpar[\"Lmax\"] = Lmax\n    mpar[\"Ntheta\"] = 100\n    script = create_group(fid, \"computation/files\") \n    script[\"script\"] = read(\"convert_julia.jl\", String)\n    \n    # write root attributes\n    attributes(fid)[\"name\"] = \"Au prolate spheroid in water\"\n    attributes(fid)[\"description\"] = \"Computation using SMARTIES, a numerically robust EBCM implementation for spheroids\"\n    attributes(fid)[\"keywords\"] = \"gold, spheroid, ebcm, passive, reciprocal, czinfinity, mirrorxyz\"    \n    attributes(fid)[\"storage_format_version\"] = \"v0.01\"\n    \n    # comp attributes\n    attributes(fid[\"computation\"])[\"method\"] = \"EBCM, Extended Boundary Condition Method\"\n    attributes(fid[\"computation\"])[\"description\"] = \"Computation using SMARTIES, a numerically robust EBCM implementation for spheroids\"\n    attributes(fid[\"computation\"])[\"name\"] = \"SMARTIES\"\n    attributes(fid[\"computation\"])[\"software\"] = software\n\nend"
  },
  {
    "objectID": "website/export_matlab.html",
    "href": "website/export_matlab.html",
    "title": "Export to ‘.tmat.h5’ format with Matlab",
    "section": "",
    "text": "This document showcases a basic Matlab script to export T-matrices in the .tmat.h5 HDF5 format. For illustration, we start by producing a dummy dataset. This minimal reproducible example file is available for download as a standalone script: export_matlab.m."
  },
  {
    "objectID": "website/export_matlab.html#mockup-input-data",
    "href": "website/export_matlab.html#mockup-input-data",
    "title": "Export to ‘.tmat.h5’ format with Matlab",
    "section": "Mockup input data",
    "text": "Mockup input data\nConsistent with the other examples, we generate a 50x30x30 array of dummy data, which repeats 50 times (50 wavelengths) a matrix of 900 entries ranging from \\(1+1i\\) (first element, top left) to \\(900 + 900i\\) (last element, bottom right). Note the expectation of row-major ordering in HDF5. The 3x3 top-left block is\n   1.0000 + 1.0000i   2.0000 + 2.0000i   3.0000 + 3.0000i ...\n  31.0000 +31.0000i  32.0000 +32.0000i  33.0000 +33.0000i ...\n  61.0000 +61.0000i  62.0000 +62.0000i  63.0000 +63.0000i ...\n   ...               ...                ...               ...\nThe easyh5 library takes care of most of the details for us, when objects are stored in Matlab structures. There are a couple of caveats, illustrated below, such as polarization being handled separately, and attributes being added at a later stage.\n\n% possibly multiple wavelengths\nwavelength  = (400:50:800)';\nNl = length(wavelength);\n\nLmax = 3;\nqmax = 2*(Lmax*(Lmax+1)+Lmax); % T-matrix size\n\n% dummy 30x30 matrix values for each wavelength\n% note the transpose due to HDF5 expecting\n% row-major ordering vs matlab's default column-major\ntdata = transpose(reshape((1:qmax^2) + 1i*(1:qmax^2), [qmax,qmax]));\n\ntmatrix = zeros(Nl,qmax,qmax);\nfor i=1:Nl\n    tmatrix(i,:,:) = tdata;\nend\n\nsqueeze(tmatrix(1,1:3,1:3))\n\n% modes, but note that polarization is turned into strings separately\ni=1;\nfor l=1:3\n    for m=-l:l\n        for s=1:2\n            modes.l(i) = int64(l);\n            modes.m(i) = int64(m);\n            modes.s(i) = int64(s);\n            i=i+1;\n        end\n    end\nend\npolars = [\"electric\", \"magnetic\"];\npolarization = polars(modes.s);\nmodes = rmfield(modes,'s');\n\n% dummy 'analytical zeros' for e.g. EBCM methods\n% [zerosq, zerosqp] = ndgrid(1:2:30, 1:2:30);\n% zeros  = struct('q', zerosq, 'qp', zerosqp);\n\n% materials\nembedding = struct('relative_permeability', 1.0, ...\n                   'relative_permittivity', 1.33^2);\nparticle = struct('relative_permeability', 1.0, ...\n                  'relative_permittivity', repmat(-11.4+1.181i, [Nl,1]));\n\n% geometry\ngeometry = struct('radiusxy', 20.0, 'radiusz', 40.0);\n\nscatterer = struct('material', particle, ...\n                  'geometry', geometry);\n\n% details about computation\n\nmethod_parameters = struct('Lmax', int64(3), ...\n                           'Ntheta', int64(100));\n\ncomputation = struct('method_parameters', method_parameters);\n% 'analytical_zeros', zeros can be added here\n\nscript = convertCharsToStrings(fileread('export_matlab.m'));\n\n% combined information into one struct\ns = struct('tmatrix', tmatrix, ...\n    'embedding', embedding,...\n    'scatterer', scatterer, ...\n    'computation', computation);"
  },
  {
    "objectID": "website/export_matlab.html#saving-to-hdf5",
    "href": "website/export_matlab.html#saving-to-hdf5",
    "title": "Export to ‘.tmat.h5’ format with Matlab",
    "section": "Saving to HDF5",
    "text": "Saving to HDF5\n\naddpath(genpath('../easyh5/'));\n\nsaveh5 does most of the work, but we have to write polarization and script separately as strings within structs seem to trip easyh5.\n\nf = 'am.tmat.h5';\n[h5major,h5minor,h5rel] = H5.get_libversion(); % HDF5 version\nmatlabv = version ; % Matlab version\nsoftware = sprintf('SMARTIES=1.1, matlab=%s, HDF5=%d.%d.%d',matlabv,h5major,h5minor,h5rel);\n\nsaveh5(s, f, 'ComplexFormat', {'r','i'}, 'rootname', '', 'Compression', 'deflate'); \n\n\n\n% deal with objects manually\n% character vectors, and also 1D vectors, \n% as easyh5 would store them as 1xN arrays for back-compatibility\n\nh5create(f,'/vacuum_wavelength', length(wavelength), 'Datatype', 'double')\nh5write(f,'/vacuum_wavelength', wavelength)\n\nh5create(f,'/modes/l', length(modes.l), 'Datatype', 'int64')\nh5write(f,'/modes/l', modes.l)\n\nh5create(f,'/modes/m', length(modes.m), 'Datatype', 'int64')\nh5write(f,'/modes/m', modes.m)\n\nh5create(f,'/modes/polarization', length(polarization), 'Datatype', 'string')\nh5write(f,'/modes/polarization', polarization)\n\n% root attributes\nh5writeatt(f, '/', 'name', 'Au prolate spheroid in water');\nh5writeatt(f, '/', 'storage_format_version', 'v1'); \nh5writeatt(f, '/','description', ...\n    'Computation using SMARTIES, a numerically robust EBCM implementation for spheroids');\nh5writeatt(f, '/','keywords', 'gold, spheroid, ebcm, passive, reciprocal, czinfinity, mirrorxyz');\n\n% object and group attributes\nh5writeatt(f, '/vacuum_wavelength', 'unit', 'nm');\n\nh5writeatt(f, '/embedding', 'keywords', 'non-dispersive');\nh5writeatt(f, '/embedding', 'name', 'H2O, Water');\n\nh5writeatt(f, '/scatterer/material', 'name', 'Au, Gold');\nh5writeatt(f, '/scatterer/material', 'reference', 'Au from Raschke et al 10.1103/PhysRevB.86.235147');\nh5writeatt(f, '/scatterer/material', 'keywords', 'dispersive, plasmonic');\n\nh5writeatt(f, '/scatterer/geometry', 'name', 'homogeneous spheroid with symmetry axis z');\nh5writeatt(f, '/scatterer/geometry', 'unit', 'nm');\nh5writeatt(f, '/scatterer/geometry', 'shape', 'spheroid')\n\nh5writeatt(f, '/computation', 'description', 'Computation using SMARTIES, a numerically robust EBCM implementation for spheroids');\nh5writeatt(f, '/computation', 'name', 'SMARTIES');\nh5writeatt(f, '/computation', 'method', 'EBCM, Extended Boundary Condition Method');\nh5writeatt(f, '/computation', 'software', software);"
  },
  {
    "objectID": "website/display.html",
    "href": "website/display.html",
    "title": "Displaying T-matrices with R",
    "section": "",
    "text": "R utility functions used below.\nThe following R code produces a visual heatmap of a T-matrix with a standard 2x2 block matrix layout and indexing conventions.\nExample data in long format:\nf &lt;- '../smarties/smarties_simple.tmat.h5'\nslices &lt;- read_tmat(f)\nd1 &lt;- slices[slices$wavelength == 400,]\nd2 &lt;- slices[slices$wavelength == 750,]\n\ndm &lt;- rbind(\n  mutate(d1, wavelength = \"400 nm\"),\n  mutate(d2, wavelength = \"750 nm\"))\nCustom visualisation:\nlmax &lt;- max(dm$l)\nbreaks &lt;- tmatrix_breaks(lmax)\n\np &lt;- ggplot(dm, aes(q, qp, fill= log10(Mod(Tr + 1i*Ti)))) +\n  geom_tile() +\n  coord_equal() + facet_wrap(~wavelength) +\n  scale_fill_viridis_c(option = 'A', direction = -1, na.value = \"transparent\") +\n  annotate('segment',x=0.5,xend=max(breaks$breaks)+0.5,y=max(breaks$breaks)/2+0.5,\n           yend=max(breaks$breaks)/2+0.5,colour='white')+\n  annotate('segment',y=0.5,yend=max(breaks$breaks)+0.5,x=max(breaks$breaks)/2+0.5,\n           xend=max(breaks$breaks)/2+0.5,colour='white')+\n  scale_y_reverse(expand=c(0,0), breaks= breaks$breaks+0.5, minor_breaks=breaks$minor_breaks+0.5, labels=breaks$labels) +\n  scale_x_continuous(expand=c(0,0), breaks= breaks$breaks+0.5, minor_breaks=breaks$minor_breaks+0.5, labels=breaks$labels) +\n  theme_minimal() +\n  theme(panel.grid = element_line(colour = 'white'), \n        panel.background = element_rect(fill='grey90',colour='white'),\n        panel.border = element_rect(colour='black',fill=NA,linewidth = 0.2),\n        axis.text.x = element_text(hjust=1),\n        axis.text.y = element_text(vjust=0)) +\n  labs(x=\"p\",y=\"p'\",fill=expression(log~\"|T\"[ij]*\"|\"))\n\np"
  },
  {
    "objectID": "website/display.html#display-in-uu-grouping",
    "href": "website/display.html#display-in-uu-grouping",
    "title": "Displaying T-matrices with R",
    "section": "Display in \\((u,u')\\) grouping",
    "text": "Display in \\((u,u')\\) grouping\nIn the tmat.h5 indexing convention, electric and magnetic elements are interleaved, leading to the following display:\n\ntreams_breaks &lt;- function(lmax){\n  \n  l &lt;- seq.int(lmax)\n  qmax &lt;- 2*(lmax*(lmax + 1)+lmax)\n  list(breaks = 2*cumsum((2*l+1)),\n       labels = 2*cumsum((2*l+1)),\n       minor_breaks = seq.int(qmax))\n}\nlmax &lt;- max(dm$l)\nbreaks &lt;- treams_breaks(lmax)\n\np &lt;- ggplot(dm, aes(u, up, fill= log10(Mod(Tr + 1i*Ti)))) +\n  geom_tile() +\n  coord_equal() + facet_wrap(~wavelength) +\n  scale_fill_viridis_c(option = 'A', direction = -1, na.value = \"transparent\") +\n  # annotate('segment',x=0.5,xend=max(breaks$breaks)+0.5,y=max(breaks$breaks)/2+0.5,\n  #          yend=max(breaks$breaks)/2+0.5,colour='white')+\n  # annotate('segment',y=0.5,yend=max(breaks$breaks)+0.5,x=max(breaks$breaks)/2+0.5,\n  #          xend=max(breaks$breaks)/2+0.5,colour='white')+\n  scale_y_reverse(expand=c(0,0), breaks= breaks$breaks+0.5, minor_breaks=breaks$minor_breaks+0.5, labels=breaks$labels) +\n  scale_x_continuous(expand=c(0,0), breaks= breaks$breaks+0.5, minor_breaks=breaks$minor_breaks+0.5, labels=breaks$labels) +\n  # scale_y_reverse(expand=c(0,0)) +\n  # scale_x_continuous(expand=c(0,0)) +\n  theme_minimal() +\n  theme(panel.grid = element_line(colour = 'white'), \n        panel.background = element_rect(fill='grey90',colour='white'),\n        panel.border = element_rect(colour='black',fill=NA,linewidth = 0.2),\n        axis.text.x = element_text(hjust=1),\n        axis.text.y = element_text(vjust=0)) +\n  labs(x=\"u\",y=\"u'\",fill=expression(log~\"|T\"[ij]*\"|\"))\n\np"
  },
  {
    "objectID": "website/smarties_batch.html",
    "href": "website/smarties_batch.html",
    "title": "Calculating many SMARTIES T-matrices",
    "section": "",
    "text": "Below is an example script to run many SMARTIES simulations and export the T-matrices in HDF5. The script is available as standalone script smarties_batch.R.\n\nlibrary(glue)\nlibrary(dplyr)\nlibrary(purrr)\n\n# read in the template\ntemplate &lt;- glue_collapse(readLines('../smarties/batch/_template.m'), sep = \"\\n\")\n\nparameters &lt;- expand.grid(a = seq(10, 100, by=5), c = seq(10, 100, by=5),\n                          material = c(\"Au\", \"Ag\", \"Si\"), \n                          medium = c(\"vacuum\", \"water\")) |&gt; \n  filter(a != c) |&gt; # use Mie for this\n  mutate(shape = ifelse(a &gt; c, \"oblate\", \"prolate\"),\n         n = ifelse(medium == \"water\", 1.33, 1.0),\n         source = case_when(material == \"Au\" ~ \"Raschke et al 10.1103/PhysRevB.86.235147\", \n                            material == \"Ag\" ~ \"Raschke et al 10.1103/PhysRevB.91.235137\",\n                            material == \"Si\" ~ \"Aspnes et al 10.1103/PhysRevB.27.985\",\n                            .default = \"Unknown material!\"))\n\nparameters$step &lt;- 1\nnrow(parameters)\n\n[1] 2052\n\n\nFor initial testing, we’ll run much fewer combinations\n\nparameters &lt;- expand.grid(a = seq(20, 50, by=10), c = seq(20, 50, by=10),\n                          material = c(\"Au\", \"Ag\"), \n                          medium = c(\"water\")) |&gt; \n  filter(a != c) |&gt; # use Mie for this\n  mutate(shape = ifelse(a &gt; c, \"oblate\", \"prolate\"),\n         n = ifelse(medium == \"water\", 1.33, 1.0),\n         source = case_when(material == \"Au\" ~ \"Raschke et al 10.1103/PhysRevB.86.235147\", \n                            material == \"Ag\" ~ \"Raschke et al 10.1103/PhysRevB.91.235137\",\n                            material == \"Si\" ~ \"Aspnes et al 10.1103/PhysRevB.27.985\",\n                            .default = \"Unknown material!\"))\nparameters$step &lt;- 5\n\nEven with these restricted options, there’s already 24 combinations.\n\n\n\n\n\n\n\n\na\nc\nshape\nmaterial\nmedium\n\n\n\n\n30\n20\noblate\nAu\nwater\n\n\n40\n20\noblate\nAu\nwater\n\n\n50\n20\noblate\nAu\nwater\n\n\n20\n30\nprolate\nAu\nwater\n\n\n40\n30\noblate\nAu\nwater\n\n\n50\n30\noblate\nAu\nwater\n\n\n20\n40\nprolate\nAu\nwater\n\n\n30\n40\nprolate\nAu\nwater\n\n\n50\n40\noblate\nAu\nwater\n\n\n20\n50\nprolate\nAu\nwater\n\n\n30\n50\nprolate\nAu\nwater\n\n\n40\n50\nprolate\nAu\nwater\n\n\n30\n20\noblate\nAg\nwater\n\n\n40\n20\noblate\nAg\nwater\n\n\n50\n20\noblate\nAg\nwater\n\n\n20\n30\nprolate\nAg\nwater\n\n\n40\n30\noblate\nAg\nwater\n\n\n50\n30\noblate\nAg\nwater\n\n\n20\n40\nprolate\nAg\nwater\n\n\n30\n40\nprolate\nAg\nwater\n\n\n50\n40\noblate\nAg\nwater\n\n\n20\n50\nprolate\nAg\nwater\n\n\n30\n50\nprolate\nAg\nwater\n\n\n40\n50\nprolate\nAg\nwater\n\n\n\n\n\n\n\nWe use the “glue” package to inject the parameters into the template, where the variables are indicated between braces {}. The process loops over each parameter combination and outputs a new file with corresponding filename.\n\nwrite_script &lt;- function(a, c, material, medium, shape, n, step, source){\n script &lt;- glue(template)   \n cat(script, file = glue('../smarties/batch/run_{material}_{medium}_{a}_{c}.m'))\n cat(glue(\"run_{material}_{medium}_{a}_{c}\\n\\n\"), \n     file = \"../smarties/batch/batch.m\", append = TRUE)\n}\ncat(\"%% Running all the files below\\n\",file = \"../smarties/batch/batch.m\", append = FALSE)\npwalk(rowwise(parameters), write_script)\n\nRunning the batch script in Matlab results in 24 output T-matrix files of size between 4 and 6Mb each, with the 5nm step defined above. The value of Lmax needed for \\(10^{-10}\\) accuracy in \\(\\langle\\sigma_\\text{ext}\\rangle\\) appears to be around 11."
  }
]